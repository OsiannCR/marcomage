<?php

/* ---------------------------- *
 * | MARCOMAGE BOOTSTRAP FILE | *
 * ---------------------------- */

// redirect errors to our own logfile
error_reporting(-1);
ini_set('error_log', 'logs/arcomage-error-' . strftime('%Y%m%d') . '.log');

// autoload setup for PSR 4 (via composer) with PSR 0 fallback
require(APPLICATION_PATH . '/vendor/autoload.php');

// autoload setup for PSR 0 (currently unused as we use composer)
//spl_autoload_register(function ($class) {
//    $class = ltrim($class, '\\');
//    return include str_replace(
//            ['\\', '_'], DIRECTORY_SEPARATOR, $class
//        ) . '.php';
//}, true, true);
//
//set_include_path(implode(PATH_SEPARATOR, [
//    realpath(APPLICATION_PATH . '/library'),
//    realpath(APPLICATION_PATH . '/src'),
//    get_include_path(),
//]));

// NOTE: this may come in handy if we want to log errors into something else (DB, external log service...)
//$dic = Dic::getInstance();
//
//set_error_handler(function ($n, $s, $f, $l, $ctx = array()) use ($dic) {
//    $dic->logger()->logError([
//        'code' => ArcomageException::CRITICAL,
//        'msg' => 'ERROR '.$s,
//        'file' => $f,
//        'line' => $l,
//    ]);
//
//    return false;
//});
//
//register_shutdown_function(function() use ($dic) {
//    $e = error_get_last();
//    $fatals = array(
//        // Fatal run-time errors. These indicate errors that can
//        // not be recovered from, such as a memory allocation problem.
//        // Execution of the script is halted.
//        E_ERROR,
//        // Fatal errors that occur during PHP's initial startup.
//        // This is like an E_ERROR, except it is generated by the
//        // core of PHP.
//        E_CORE_ERROR,
//        // Compile-time parse errors. Parse errors should only be
//        // generated by the parser.
//        E_PARSE
//    );
//
//    // proceed only if we detect fatal error
//    if ($e !== null && in_array($e['type'], $fatals)) {
//        // web server can have an automatic failover setting enabled for specific error codes
//        // in this case web server will silently retry whole request on different backend
//        // this needs to be disabled, because we don't want to do this retry on error
//        // setting name: proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;
//
//        // set header so we can easily see the result in browser network screen
//        header('HTTP/1.0 500 Internal Server Error');
//
//        $dic->logger()->logError([
//            'code' => ArcomageException::CRITICAL,
//            'msg' => 'FATAL '.$e["type"].' '.$e["message"],
//            'file' => $e["file"],
//            'line' => $e["line"],
//        ]);
//    }
//});

//function fail($message)
//{
//    error_log('MArcomage Fatal error: ' . $message);
//    header('Location: fail.php?error=' . urlencode($message));
//    die();
//}

if (date_default_timezone_set('Etc/UTC') === false) {
    throw new ArcomageException('unable to configure timezone');
}

// encoding settings
mb_internal_encoding('UTF-8');
mb_http_output('UTF-8');

// config setup
Dic::setConfig(
    require(APPLICATION_PATH . '/src/config.php'),
    (file_exists(APPLICATION_PATH . '/src/config_production.php'))
        ? require(APPLICATION_PATH . '/src/config_production.php') : []
);
